//把相同的数据离散化为相同的数据
//或者后出现的数据比先出现的大
#include <iostream>
#include <algorithm>
using namespace std;
using ll = long long;
const int N = 1e6 + 5;

struct datax
{
    int val;
    int id;
}olda[N];
int newa[N];
bool cmp(datax x, datax y)            //自定义比较函数
{
    return x.val < y.val;             //默认顺序是 x y，返回值为真则不动，为假就调换
}
int main()
{
    int n; cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> olda[i].val;
        olda[i].id = i;
    }
    sort(olda + 1, olda + 1 + n, cmp);
    for (int i = 1; i <= n; i++)
    {
        newa[olda[i].id] = i;                     //这个元素原来的位置在olda[i].id，把它的新值赋为i

        if (olda[i].val == olda[i - 1].val) 
        { 
            newa[olda[i].id] = newa[olda[i - 1].id];           //若两个元素原来的值相同，把新值赋为相同
                                                               //要求后出现的数据比先出现的大，把此行注释
        }        
    }
    for (int i = 1; i <= n; i++)
    {
        cout << newa[i] << " ";
    }
    return 0;
}

##############################使用STL##########################################
#include <iostream>
#include <algorithm>
using namespace std;
using ll = long long;
const int N = 1e6 + 5;
int olda[N], newa[N];

int main()
{
    int n; cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> olda[i];
        newa[i] = olda[i];
    }
    sort(olda + 1, olda + 1 + n);
    int cnt = n;
    //cnt = unique(olda + 1, olda + 1 + n) - (olda + 1);
    //去重，cnt是去重后的数量
    for (int i = 1; i <= cnt; i++)
    {
        newa[i] = lower_bound(olda + 1, olda + 1 + n, newa[i]) - olda;     //查找相等元素的位置，这个位置就是离散化后的新值                            
    }
    for (int i = 1; i <= cnt; i++)
    {
        cout << newa[i] << " ";
    }
    return 0;
} 

