//动态链表基本操作
struct node
{
    int data;
    node* next;
};
int main()
{
    int n, m; cin >> n >> m;
    node* head, * now, * pre, * suc;          //头节点，现节点，前驱节点，后继节点
    head = new node; head->data = 1; head->next = nullptr;
    now = head;
    for (int i = 2; i <= n; i++)
    {
        suc = new node;
        suc->data = i;
        suc->next = nullptr;
        
        now->next = suc;
        now = suc;
    }
    now->next = head;
    return 0;
}

/*利用两个一维数组建立双向静态链表
 *插入与删除操作不需要前驱指针
 */
int pre[N], suc[N];    //前驱与后继
int data[N];
int n; cin >> n;
int now = 1;
suc[now] = 0; pre[now] = 0;
suc[0] = now; pre[0] = now;
for (int i = 2; i <= n; i++)
{
    int flag;
    cin >> now >> flag;
    if (flag == 0)
    {
        suc[pre[now]] = i; pre[i] = pre[now]; 
        pre[now] = i; suc[i] = now;
    }
    else if( flag == 1 )
    {
        pre[suc[now]] = i; suc[i] = suc[now]; 
        suc[now] = i; pre[i] = now;
    }
}

#####################################双向动态链表###############################
#include <iostream>
#include <algorithm>
#include <stack>
#include <string>
using namespace std;
const int N = 1e5 + 5;

struct node
{
    char s;
    node* prev;
    node* next;
};

int main()
{
    string a;
    getline(cin,a);             //可读入一行字符串，包括空格
    int len = a.length();

    node* head = new node;
    node* tail = new node;
    head->s = tail->s = len;
    head->next = tail; head->prev = NULL;
    tail->next = NULL; tail->prev = head;

    node* now = head;

    for (int i = 0; i < len; i++)
    {
        if (a[i] == '{')
        {
            now = head;
        }
        else if (a[i] == '}')
        {
            now = tail->prev;
        }
        else if (a[i] == '>')
        {
            if (now->next != tail)
                now = now->next;
        }
        else if (a[i] == '<')
        {
            if (now != head)
                now = now->prev;
        }
        else if (a[i] == '#')          
        {
            if (now == head)continue;
            node* temp = now->prev;
            now->prev->next = now->next;
            now->next->prev = now->prev;
            delete now;
            now = temp;                      //光标右移，此步非常重要
        }
        else
        {
            node* p = new node;
            p->s = a[i];
            p->next = now->next;
            now->next->prev = p;
            now->next = p;
            p->prev = now;
            now = now->next;
        }
    }
    now = head;
    while (now->next != tail)
    {
        now = now->next;
        cout << now->s;
    }
    now = head;
    while (now->next != NULL)
    {
        now = now->next;
        delete head;
        head = now;
    }
    return 0;
}
